<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mesure P√©tanque / Palets</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents double tap zoom */
        }
        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        #video, #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
        }
        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0));
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 5px solid white;
            background-color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .capture-btn:active {
            transform: scale(0.9);
            background-color: white;
        }
        .reset-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background-color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        .visible {
            opacity: 1;
        }
        #results {
            position: fixed;
            top: 80px;
            left: 10px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            max-height: calc(100% - 180px);
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-black text-white">

    <!-- Conteneur pour la vid√©o et le canvas -->
    <div class="video-container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- Bo√Æte de message pour les instructions -->
    <div id="messageBox" class="message-box"></div>

    <!-- Panneau pour afficher les r√©sultats -->
    <div id="results" class="hidden"></div>

    <!-- Boutons de contr√¥le -->
    <div id="controls" class="controls">
        <button id="resetBtn" class="reset-btn hidden">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M21 21v-5h-5"/></svg>
        </button>
        <button id="captureBtn" class="capture-btn"></button>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const captureBtn = document.getElementById('captureBtn');
        const resetBtn = document.getElementById('resetBtn');
        const controlsDiv = document.getElementById('controls');
        const messageBox = document.getElementById('messageBox');
        const resultsDiv = document.getElementById('results');

        let points = []; // Stocke les points cliqu√©s {x, y}
        let jack = null; // Stocke le point du cochonnet
        let imageCaptured = false;

        // Fonction pour afficher des messages √† l'utilisateur
        function showMessage(text, duration = 3000) {
            messageBox.textContent = text;
            messageBox.classList.add('visible');
            setTimeout(() => {
                messageBox.classList.remove('visible');
            }, duration);
        }

        // D√©marrer la cam√©ra
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment', // Cam√©ra arri√®re
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    showMessage("Visez et appuyez sur le bouton pour capturer");
                };
            } catch (err) {
                console.error("Erreur d'acc√®s √† la cam√©ra: ", err);
                showMessage("Impossible d'acc√©der √† la cam√©ra. V√©rifiez les autorisations.");
                // Fallback for desktop or browsers without environment camera
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                       showMessage("Visez et appuyez sur le bouton pour capturer");
                    };
                } catch (fallbackErr) {
                    console.error("Erreur d'acc√®s √† la cam√©ra (fallback): ", fallbackErr);
                    showMessage("Aucune cam√©ra disponible.");
                }
            }
        }

        // Dessiner sur le canvas
        function draw() {
            if (!imageCaptured) return;

            // 1. Redessiner l'image de fond
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 2. Dessiner le cochonnet
            if (jack) {
                context.beginPath();
                context.arc(jack.x, jack.y, 15, 0, 2 * Math.PI);
                context.fillStyle = 'rgba(255, 0, 255, 0.8)'; // Magenta pour le cochonnet
                context.fill();
                context.strokeStyle = 'white';
                context.lineWidth = 2;
                context.stroke();
            }

            // 3. Dessiner les boules et les lignes
            let distances = [];
            if (jack && points.length > 0) {
                points.forEach((point, index) => {
                    const dist = Math.sqrt(Math.pow(point.x - jack.x, 2) + Math.pow(point.y - jack.y, 2));
                    distances.push({ index, dist });
                });

                // Trier pour trouver la plus proche
                distances.sort((a, b) => a.dist - b.dist);
                const closestIndex = distances.length > 0 ? distances[0].index : -1;

                points.forEach((point, index) => {
                    const isClosest = index === closestIndex;
                    
                    // Ligne
                    context.beginPath();
                    context.moveTo(jack.x, jack.y);
                    context.lineTo(point.x, point.y);
                    context.strokeStyle = isClosest ? 'rgba(0, 255, 0, 0.9)' : 'rgba(255, 255, 0, 0.7)'; // Vert pour la plus proche, jaune sinon
                    context.lineWidth = isClosest ? 4 : 2;
                    context.stroke();
                    
                    // Point (boule)
                    context.beginPath();
                    context.arc(point.x, point.y, 15, 0, 2 * Math.PI);
                    context.fillStyle = isClosest ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 255, 0, 0.7)';
                    context.fill();
                    context.strokeStyle = 'white';
                    context.lineWidth = 2;
                    context.stroke();

                    // Texte de la distance
                    const midX = (jack.x + point.x) / 2;
                    const midY = (jack.y + point.y) / 2;
                    context.fillStyle = 'white';
                    context.font = 'bold 16px Inter';
                    context.shadowColor = 'black';
                    context.shadowBlur = 4;
                    context.fillText(distances.find(d => d.index === index).dist.toFixed(1), midX + 5, midY - 5);
                    context.shadowBlur = 0;
                });
            }
            updateResults(distances);
        }

        function updateResults(distances) {
            if (distances.length === 0) {
                resultsDiv.classList.add('hidden');
                return;
            }
            resultsDiv.classList.remove('hidden');
            let html = '<h3 class="font-bold mb-2">Distances (en pixels)</h3>';
            distances.forEach((item, rank) => {
                const isClosest = rank === 0;
                html += `<div class="${isClosest ? 'text-green-400 font-bold' : ''}">
                    ${isClosest ? 'üèÜ' : ''} Boule ${item.index + 1}: ${item.dist.toFixed(1)}
                </div>`;
            });
            resultsDiv.innerHTML = html;
        }


        // √âv√©nement du bouton de capture
        captureBtn.addEventListener('click', () => {
            if (imageCaptured) return; // Emp√™che de recapturer par-dessus

            // Ajuster la taille du canvas √† la taille de la vid√©o affich√©e
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            video.pause();
            video.classList.add('hidden'); // Cacher la vid√©o pour ne voir que le canvas
            
            imageCaptured = true;
            captureBtn.classList.add('hidden');
            resetBtn.classList.remove('hidden');
            showMessage("Touchez le cochonnet/ma√Ætre pour le placer");
        });

        // √âv√©nement du clic sur le canvas
        canvas.addEventListener('click', (e) => {
            if (!imageCaptured) return;

            // Obtenir les coordonn√©es du clic par rapport au canvas
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (!jack) {
                jack = { x, y };
                showMessage("Maintenant, touchez les boules/palets");
            } else {
                points.push({ x, y });
            }
            draw();
        });

        // √âv√©nement du bouton de r√©initialisation
        resetBtn.addEventListener('click', () => {
            points = [];
            jack = null;
            imageCaptured = false;

            context.clearRect(0, 0, canvas.width, canvas.height);
            video.classList.remove('hidden');
            video.play();

            captureBtn.classList.remove('hidden');
            resetBtn.classList.add('hidden');
            resultsDiv.classList.add('hidden');
            
            showMessage("Visez et appuyez sur le bouton pour capturer");
        });

        // D√©marrer l'application
        window.addEventListener('load', startCamera);
    </script>
</body>
</html>
